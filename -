use std::sync::Arc;

use bcrypt::{DEFAULT_COST, hash, verify};
use chrono::{DateTime, Utc};
use jsonwebtoken::{EncodingKey, Header, jws::encode};
use serde::{Deserialize, Serialize};
use thiserror::Error;
use uuid::Uuid;

use crate::{domain::user::User, use_cases::user_database::UserDatabase};

type AuthResult<T> = Result<T, AuthError>;

#[derive(Debug, Serialize, Deserialize)]
struct Claims {
    exp: usize,
    sub: String,
}

pub async fn login(
    database: Arc<impl UserDatabase>,
    username: String,
    email: String,
    password: String,
    jwt_secret: String,
) -> AuthResult<String> {
    let user = match database.get_user_by_username(username).await {
        Ok(user) => user,
        Err(_) => match database.get_user_by_email(email).await {
            Ok(user) => user,
            Err(err) => return Err(AuthError::DatabaseError(err.to_string())),
        },
    };

    let succesful = verify(password, &user.password_hash)
        .map_err(|err| AuthError::ErrorVerifying(err.to_string()))?;

    if succesful {
        let my_claims = Claims {
            exp: Utc::now().timestamp() as usize,
            sub: format!("{}", user.id),
        };

        let token = encode(
            &Header::default(),
            &my_claims,
            &EncodingKey::from_secret(jwt_secret.as_ref()),
        );
    }

    Ok("hoa".to_string())
}

pub async fn register(
    database: Arc<impl UserDatabase>,
    username: String,
    password: String,
    email: String,
) -> AuthResult<()> {
    let encrypted_password = hash(password, DEFAULT_COST)
        .map_err(|err| AuthError::PasswordHashingFailed(err.to_string()))?;

    let user = User {
        id: Uuid::new_v4(),
        username,
        email,
        password_hash: encrypted_password,
        created_at: Utc::now(),
        updated_at: Utc::now(),
    };

    database
        .create_user(user)
        .await
        .map_err(|err| AuthError::DatabaseError(err.to_string()))?;

    Ok(())
}
#[derive(Error, Debug)]
pub enum AuthError {
    #[error("Failed password hashing: {0}")]
    PasswordHashingFailed(String),
    #[error("database error")]
    DatabaseError(String),
    #[error("error verifying")]
    ErrorVerifying(String),
    #[error("invalid credentials")]
    InvalidCredentials,
}

#[cfg(test)]
mod test {
    use std::sync::Arc;

    use bcrypt::{hash, verify};
    use mockall::predicate;

    use crate::use_cases::{auth_service::register, user_database::MockUserDatabase};

    #[tokio::test]
    async fn register_test() {
        let mut db = MockUserDatabase::new();

        db.expect_create_user()
            .withf(|user| verify("password123", &user.password_hash).unwrap_or(false))
            .once()
            .returning(|_| Ok(()));

        register(
            Arc::new(db),
            "juan".to_string(),
            "password123".to_string(),
            "juan@juan.juan".to_string(),
        )
        .await
        .unwrap();
    }
}
